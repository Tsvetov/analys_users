Это приложение для django(1.8).

Идея такая:

    1. Денормализовать исходные данные.
        Исходная таблица:
            UserIp:
                user_id
                ip_address
                date

        Таблица денормализации:
            UserSubNetwork:
                user_id
                sub_networks

        Где sub_networks - это массив подсетей пользователя.


    2. Синхронизировать данные в бд с помощью тригера SQL(
        текст триггрера находиться в файле trigger_total)
        При записи(INSERT) новой пары user_id-ip_address в таблицу UserIp в таблицу
        UserSubNetwork записывается информация о паре user-sub_network(если такой еще нет).

    3. Поставить индекс на колонку UserSubNetwork.user_id
        (На сколько я знаю orm django ставит индекс по умолчания - B-дерево,
        но правильнее бы поставить хэш индекс(так как запросы на выборку данных идут по равенству)).

    4. После вышеупомянутых манипуляций,вытащить из базы нужные нам
        данные и посчитать результат не состовляет труда.

        То есть вытаскивается список подсетей одного пользователя, список подсетей второго пользователя.
        Эти списки преобразуются в set'ы, пересекаются. И, если, результат пересечение >2 => пользователи взаимосвязаны,
        иначе (варианты: пользователей нет в базе, пересечение < 2...) => Пользователи не взаимосвязаны.

Примерный результат тестов:
    1000 user_id ~ 0.74 ms
    10000 user_id ~1.3 ms
    1000000 user_id ~2.5 ms
    10000000 user_id ~2.7 ms

    Надо добавить что количество user - это колличество уникальных пользователей.
    Т.Е. записей в исходной таблице было в ~3~4 раза больше.

    ТЕсты проводились как на положительный так и на отрицательный результат.

Так же. Не стал создавать дополнительную таблицу отношений user-user,
так как новая таблица в неявном виде, по сути, хранит эти отношения(Хотя момент спорный).


TODO(возможные улучшения):
    1. Поставить хэш-index на колонку  UserSubNetwork.user_id.
    2. Внести добавление хэш-index'a в миграции.
    3. Внести триггрер в миграции(что бы его загружать миграциями, а не в ручную).
    4. Написать unit-test'ы на модуль utils(без 2-го пункта их по сути не зачем писать).
    5. Передавать данные по json.


У меня было несколько вариантов решений. Остановился на нем - потому как:
- из всех моих решений максимальная скорость.
- при увеличении данных скорость практически не меняется.
- простота кода.

Минусы данного подхода:
- перекладывая часть расчетов на момент записи исходных данных в таблицу(trigger), мы можем потерять в скорости
сервисов(которые эти данные пишут)
- Много SQL-кода.

Для запуска, нужно прописать в settings.install_apps название приложения analys_users, и прописать urls:

url(r'^users_check/$', UsersView.as_view()),
url(r'^res/$', res_view)